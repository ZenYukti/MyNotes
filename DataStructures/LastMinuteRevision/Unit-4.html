<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit 4: Trees | ZenYukti</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-slate-50 text-slate-900 font-sans">
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState } = React;

        const TREE_CONTENT = [
            {
                id: 1,
                title: "1. Tree Terminology & Basics",
                boxes: [
                    {
                        type: "yellow",
                        title: "Key Definitions",
                        items: [
                            "**Tree**: Non-linear hierarchical data structure with nodes and edges",
                            "**Root**: Topmost node (no parent)",
                            "**Parent**: Node with children below it",
                            "**Child**: Node directly connected below parent",
                            "**Siblings**: Nodes with same parent",
                            "**Leaf/Terminal**: Node with no children",
                            "**Internal Node**: Node with at least one child",
                            "**Degree**: Number of children of a node",
                            "**Level**: Distance from root (root is level 0)",
                            "**Height**: Maximum level in tree (longest path from root to leaf)",
                            "**Depth**: Level of a node from root",
                            "**Ancestor**: All nodes on path from root to node",
                            "**Descendant**: All nodes in subtree below node"
                        ]
                    },
                    {
                        type: "yellow",
                        title: "Binary Tree Properties",
                        items: [
                            "**Binary Tree**: Each node has at most 2 children (left, right)",
                            "**Maximum nodes at level i**: 2^i",
                            "**Maximum nodes with height h**: 2^(h+1) - 1",
                            "**Minimum height for n nodes**: log‚ÇÇ(n+1) - 1",
                            "**Number of leaf nodes**: Internal nodes + 1 (for full binary tree)"
                        ]
                    }
                ]
            },
            {
                id: 2,
                title: "2. Types of Binary Trees",
                boxes: [
                    {
                        type: "purple",
                        title: "A. Strictly/Full Binary Tree",
                        items: [
                            "Every node has either 0 or 2 children",
                            "No node has exactly 1 child",
                            "Leaf nodes: (n+1)/2, Internal nodes: (n-1)/2"
                        ]
                    },
                    {
                        type: "purple",
                        title: "B. Complete Binary Tree",
                        items: [
                            "All levels completely filled except possibly last",
                            "Last level filled from left to right",
                            "Used in Binary Heap implementation",
                            "Efficient array representation possible"
                        ]
                    },
                    {
                        type: "purple",
                        title: "C. Extended/Full Binary Tree",
                        items: [
                            "Replace null pointers with special nodes",
                            "Internal nodes: Original nodes",
                            "External nodes: Special nodes (leaves)",
                            "Used in expression trees"
                        ]
                    },
                    {
                        type: "purple",
                        title: "D. Perfect Binary Tree",
                        items: [
                            "All internal nodes have 2 children",
                            "All leaves at same level",
                            "Total nodes: 2^(h+1) - 1"
                        ]
                    },
                    {
                        type: "purple",
                        title: "E. Balanced Binary Tree",
                        items: [
                            "Height difference of left and right subtrees ‚â§ 1",
                            "Ensures O(log n) operations",
                            "Examples: AVL Trees, Red-Black Trees"
                        ]
                    }
                ]
            },
            {
                id: 3,
                title: "3. Tree Representations",
                boxes: [
                    {
                        type: "purple",
                        title: "A. Array Representation",
                        items: [
                            "**Root at index**: 0",
                            "**Left child of i**: 2i + 1",
                            "**Right child of i**: 2i + 2",
                            "**Parent of i**: (i-1)/2",
                            "**Space**: O(2^h) - Wasteful for sparse trees",
                            "**Best for**: Complete binary trees"
                        ],
                        code: `Example: Tree [A, B, C, D, E]
Index: 0  1  2  3  4
       A  B  C  D  E
       
Left(1) = 2*1+1 = 3 ‚Üí D
Right(1) = 2*1+2 = 4 ‚Üí E`
                    },
                    {
                        type: "purple",
                        title: "B. Pointer/Linked Representation",
                        items: [
                            "Each node contains: data, left pointer, right pointer",
                            "**Space**: O(n) - Efficient for any tree",
                            "**Flexible**: Easy insertion/deletion",
                            "**Dynamic**: No size limitations"
                        ],
                        code: `struct Node {
    int data;
    Node* left;
    Node* right;
};`
                    }
                ]
            },
            {
                id: 4,
                title: "4. Tree Traversals",
                boxes: [
                    {
                        type: "blue",
                        title: "A. Inorder Traversal (LNR)",
                        items: [
                            "**Order**: Left ‚Üí Node ‚Üí Right",
                            "**BST Property**: Gives sorted sequence",
                            "**Use**: Expression evaluation, BST sorting"
                        ],
                        code: `Inorder(node):
1. If node is NULL, return
2. Inorder(node.left)
3. Visit node
4. Inorder(node.right)

Example Tree:
        A
       / \\
      B   C
     / \\
    D   E

Execution:
Step 1: Go left to B
Step 2: Go left to D (leaf)
Step 3: Visit D ‚Üí Output: D
Step 4: Back to B, visit B ‚Üí Output: D, B
Step 5: Go right to E, visit E ‚Üí Output: D, B, E
Step 6: Back to A, visit A ‚Üí Output: D, B, E, A
Step 7: Go right to C, visit C ‚Üí Output: D, B, E, A, C

Inorder Result: D B E A C`
                    },
                    {
                        type: "blue",
                        title: "B. Preorder Traversal (NLR)",
                        items: [
                            "**Order**: Node ‚Üí Left ‚Üí Right",
                            "**Use**: Copy tree, Prefix expression, Serialize tree"
                        ],
                        code: `Preorder(node):
1. If node is NULL, return
2. Visit node
3. Preorder(node.left)
4. Preorder(node.right)

Same Tree:
        A
       / \\
      B   C
     / \\
    D   E

Execution:
Step 1: Visit A ‚Üí Output: A
Step 2: Go left to B, visit B ‚Üí Output: A, B
Step 3: Go left to D, visit D ‚Üí Output: A, B, D
Step 4: Back to B, go right to E, visit E ‚Üí Output: A, B, D, E
Step 5: Back to A, go right to C, visit C ‚Üí Output: A, B, D, E, C

Preorder Result: A B D E C`
                    },
                    {
                        type: "blue",
                        title: "C. Postorder Traversal (LRN)",
                        items: [
                            "**Order**: Left ‚Üí Right ‚Üí Node",
                            "**Use**: Delete tree, Postfix expression, Calculate tree size"
                        ],
                        code: `Postorder(node):
1. If node is NULL, return
2. Postorder(node.left)
3. Postorder(node.right)
4. Visit node

Same Tree:
        A
       / \\
      B   C
     / \\
    D   E

Execution:
Step 1: Go left to B, then to D (leaf)
Step 2: Visit D ‚Üí Output: D
Step 3: Back to B, go right to E, visit E ‚Üí Output: D, E
Step 4: Visit B ‚Üí Output: D, E, B
Step 5: Back to A, go right to C, visit C ‚Üí Output: D, E, B, C
Step 6: Visit A ‚Üí Output: D, E, B, C, A

Postorder Result: D E B C A`
                    },
                    {
                        type: "blue",
                        title: "D. Level Order Traversal",
                        items: [
                            "**Order**: Level by level, left to right",
                            "**Data Structure**: Queue",
                            "**Use**: BFS, Shortest path in tree"
                        ],
                        code: `LevelOrder(root):
1. Queue Q
2. Q.enqueue(root)
3. While Q not empty:
   - node = Q.dequeue()
   - Visit node
   - Enqueue left, right children

Same Tree:
        A       ‚Üê Level 0
       / \\
      B   C     ‚Üê Level 1
     / \\
    D   E       ‚Üê Level 2

Execution:
Queue: [A]
Dequeue A, visit A ‚Üí Output: A, Queue: [B, C]
Dequeue B, visit B ‚Üí Output: A, B, Queue: [C, D, E]
Dequeue C, visit C ‚Üí Output: A, B, C, Queue: [D, E]
Dequeue D, visit D ‚Üí Output: A, B, C, D, Queue: [E]
Dequeue E, visit E ‚Üí Output: A, B, C, D, E

Level Order Result: A B C D E`
                    },
                    {
                        type: "green",
                        items: [
                            "**Time Complexity**: O(n) for all traversals",
                            "**Space Complexity**: O(h) for recursive, O(w) for level order (w = max width)"
                        ]
                    }
                ]
            },
            {
                id: 5,
                title: "5. Construct Tree from Traversals",
                boxes: [
                    {
                        type: "blue",
                        title: "From Inorder + Preorder",
                        items: [
                            "**Preorder**: First element is root",
                            "**Inorder**: Elements left of root are left subtree, right are right subtree",
                            "**Method**: Pick root from preorder, partition inorder, recurse"
                        ],
                        code: `Example:
Inorder:  D B E A F C
Preorder: A B D E C F

Step 1: A is root (first in preorder)
Step 2: In inorder, [D B E] left, [F C] right
Step 3: Next in preorder is B (root of left)
Step 4: Recursively build subtrees`
                    },
                    {
                        type: "blue",
                        title: "From Inorder + Postorder",
                        items: [
                            "**Postorder**: Last element is root",
                            "**Inorder**: Partition by root",
                            "**Method**: Pick root from end of postorder, partition inorder, recurse"
                        ],
                        code: `Example:
Inorder:   D B E A F C
Postorder: D E B F C A

Step 1: A is root (last in postorder)
Step 2: Partition inorder: [D B E] | [F C]
Step 3: Last in left postorder is B
Step 4: Recursively build`
                    },
                    {
                        type: "yellow",
                        items: [
                            "**Note**: Cannot uniquely construct from Preorder + Postorder alone",
                            "**Requirement**: Need Inorder + one other traversal"
                        ]
                    }
                ]
            },
            {
                id: 6,
                title: "6. Binary Search Tree (BST) Operations",
                boxes: [
                    {
                        type: "green",
                        title: "BST Properties",
                        items: [
                            "**Left subtree**: All values < node value",
                            "**Right subtree**: All values > node value",
                            "**Inorder traversal**: Sorted sequence",
                            "**Search complexity**: O(h) where h = height"
                        ]
                    },
                    {
                        type: "green",
                        title: "A. Search Operation",
                        code: `Search(node, key):
1. If node is NULL, return NULL
2. If key == node.data, return node
3. If key < node.data, Search(left)
4. Else Search(right)

Time: O(h), Space: O(h)`,
                        items: [
                            "**Best case**: O(log n) - Balanced tree",
                            "**Worst case**: O(n) - Skewed tree"
                        ]
                    },
                    {
                        type: "green",
                        title: "B. Insert Operation",
                        code: `Insert(node, key):
1. If node is NULL, create new node
2. If key < node.data:
   - node.left = Insert(left, key)
3. Else if key > node.data:
   - node.right = Insert(right, key)
4. Return node

Time: O(h)`,
                        items: [
                            "Always insert at leaf position",
                            "Maintains BST property"
                        ]
                    },
                    {
                        type: "green",
                        title: "C. Delete Operation",
                        items: [
                            "**Case 1 (Leaf node)**: Simply remove",
                            "**Case 2 (1 child)**: Replace node with child",
                            "**Case 3 (2 children)**: Replace with inorder successor/predecessor"
                        ],
                        code: `Delete(node, key):
1. Find node to delete
2. Case 1: Leaf ‚Üí remove
3. Case 2: 1 child ‚Üí bypass node
4. Case 3: 2 children ‚Üí
   - Find inorder successor (min in right)
   - Replace data with successor
   - Delete successor

Example: Delete 50 from BST

Original Tree:
        50
       /  \\
     30    70
    /  \\   /  \\
   20  40 60  80

Case 1 - Delete 20 (Leaf):
        50
       /  \\
     30    70
       \\   /  \\
       40 60  80

Case 2 - Delete 30 (1 child):
        50
       /  \\
     40    70
          /  \\
        60   80

Case 3 - Delete 50 (2 children):
Inorder Successor of 50 = 60 (leftmost in right subtree)
Replace 50 with 60:
        60
       /  \\
     40    70
             \\
             80`
                    }
                ]
            },
            {
                id: 7,
                title: "7. Advanced Tree Structures",
                boxes: [
                    {
                        type: "purple",
                        title: "A. Threaded Binary Trees",
                        items: [
                            "**Problem**: NULL pointers waste space",
                            "**Solution**: Replace NULL with threads (pointers to inorder predecessor/successor)",
                            "**One-way**: Right NULL ‚Üí inorder successor",
                            "**Two-way**: Both NULLs ‚Üí predecessor/successor",
                            "**Advantage**: Inorder traversal without stack/recursion",
                            "**Use**: Memory-efficient traversal"
                        ],
                        code: `struct ThreadedNode {
    int data;
    Node* left;
    Node* right;
    bool isThreaded; // right is thread?
};`
                    },
                    {
                        type: "purple",
                        title: "B. Huffman Coding Tree",
                        items: [
                            "**Purpose**: Data compression using frequency",
                            "**Method**: Build tree bottom-up using min-heap",
                            "**Property**: Variable-length prefix codes",
                            "**Steps**: 1) Calculate frequencies, 2) Build min-heap, 3) Merge two smallest, 4) Repeat"
                        ],
                        code: `Example: {A:5, B:9, C:12, D:13, E:16, F:45}
1. Heap: [A:5, B:9, C:12, D:13, E:16, F:45]
2. Merge A,B ‚Üí AB:14
3. Continue merging smallest
4. Codes: Left=0, Right=1

Result:
F: 0 (most frequent)
C: 100
D: 101
E: 11
AB: 110/111`
                    },
                    {
                        type: "purple",
                        title: "C. AVL Trees",
                        items: [
                            "**Definition**: Self-balancing BST",
                            "**Balance Factor**: height(left) - height(right)",
                            "**Balanced**: BF ‚àà {-1, 0, 1}",
                            "**Rotations**: LL, RR, LR, RL",
                            "**LL Rotation**: Right rotate at unbalanced node",
                            "**RR Rotation**: Left rotate at unbalanced node",
                            "**LR Rotation**: Left rotate child, right rotate parent",
                            "**RL Rotation**: Right rotate child, left rotate parent",
                            "**Time**: O(log n) for all operations"
                        ]
                    },
                    {
                        type: "purple",
                        title: "D. B-Trees",
                        items: [
                            "**Definition**: Self-balancing m-way search tree",
                            "**m-way**: Node can have m children, m-1 keys",
                            "**Properties**: All leaves at same level, minimum keys = ‚åàm/2‚åâ-1",
                            "**Use**: Database indexing, file systems",
                            "**Advantage**: Reduces disk access (nodes = disk blocks)"
                        ]
                    },
                    {
                        type: "purple",
                        title: "E. Binary Heap",
                        items: [
                            "**Definition**: Complete binary tree with heap property",
                            "**Max-Heap**: Parent ‚â• children",
                            "**Min-Heap**: Parent ‚â§ children",
                            "**Array representation**: Efficient, no pointers",
                            "**Operations**: Insert O(log n), Delete O(log n), Get-Min/Max O(1)",
                            "**Use**: Priority queues, Heap sort"
                        ],
                        code: `Insert: Add at end, bubble up
Delete: Replace root with last, bubble down
Heapify: O(n) to build heap`
                    }
                ]
            },
            {
                id: 8,
                title: "üìå Quick Revision Summary",
                boxes: [
                    {
                        type: "red",
                        title: "Tree Operations Complexity",
                        table: [
                            ["Operation", "BST Average", "BST Worst", "AVL", "Heap"],
                            ["Search", "O(log n)", "O(n)", "O(log n)", "O(n)"],
                            ["Insert", "O(log n)", "O(n)", "O(log n)", "O(log n)"],
                            ["Delete", "O(log n)", "O(n)", "O(log n)", "O(log n)"],
                            ["Get Min/Max", "O(log n)", "O(n)", "O(log n)", "O(1)"]
                        ]
                    },
                    {
                        type: "red",
                        title: "Traversal Formulas",
                        items: [
                            "**Inorder (LNR)**: Left ‚Üí Node ‚Üí Right ‚Üí Gives sorted for BST",
                            "**Preorder (NLR)**: Node ‚Üí Left ‚Üí Right ‚Üí Root first",
                            "**Postorder (LRN)**: Left ‚Üí Right ‚Üí Node ‚Üí Root last",
                            "**Level Order**: BFS using queue"
                        ]
                    },
                    {
                        type: "red",
                        title: "Key Exam Questions",
                        questions: [
                            {
                                q: "Q1: How to delete node with 2 children in BST?",
                                a: [
                                    "Find inorder successor (smallest in right subtree)",
                                    "Replace node's data with successor's data",
                                    "Delete the successor (it has at most 1 child)"
                                ]
                            },
                            {
                                q: "Q2: Array representation formulas?",
                                a: [
                                    "Parent of i: (i-1)/2",
                                    "Left child of i: 2i+1",
                                    "Right child of i: 2i+2",
                                    "Best for complete binary trees"
                                ]
                            },
                            {
                                q: "Q3: Difference between Full and Complete Binary Tree?",
                                a: [
                                    "**Full/Strict**: Every node has 0 or 2 children",
                                    "**Complete**: All levels filled except last, last filled left to right",
                                    "Complete trees can be efficiently stored in arrays"
                                ]
                            },
                            {
                                q: "Q4: AVL Rotations?",
                                a: [
                                    "**LL (Left-Left)**: Right rotation",
                                    "**RR (Right-Right)**: Left rotation",
                                    "**LR (Left-Right)**: Left rotate child, then right rotate parent",
                                    "**RL (Right-Left)**: Right rotate child, then left rotate parent"
                                ]
                            },
                            {
                                q: "Q5: Construct tree from which traversals?",
                                a: [
                                    "**Need**: Inorder + (Preorder OR Postorder)",
                                    "Cannot uniquely construct from Preorder + Postorder",
                                    "Inorder needed to identify left/right subtrees"
                                ]
                            }
                        ]
                    },
                    {
                        type: "red",
                        title: "Must Remember",
                        items: [
                            "**Max nodes at level i**: 2^i",
                            "**Max nodes with height h**: 2^(h+1) - 1",
                            "**BST Inorder**: Always gives sorted sequence",
                            "**Threaded trees**: No NULL pointers, efficient traversal",
                            "**Huffman**: Build from bottom using min frequencies",
                            "**AVL Balance Factor**: |BF| ‚â§ 1 always",
                            "**B-Tree**: m-way, all leaves at same level",
                            "**Heap**: Complete binary tree, parent-child property",
                            "**Complete tree**: Best for array representation"
                        ]
                    }
                ]
            }
        ];

        const Box = ({ type, title, items, code, table, questions }) => {
            const colors = {
                yellow: 'bg-yellow-50 border-yellow-200',
                blue: 'bg-blue-50 border-blue-200',
                green: 'bg-green-50 border-green-200',
                purple: 'bg-purple-50 border-purple-200',
                red: 'bg-red-50 border-red-200'
            };

            return (
                <div className={`${colors[type]} border-2 rounded-lg p-5 mb-5`}>
                    {title && <h3 className="font-bold text-xl mb-4">{title}</h3>}
                    
                    {items && (
                        <ul className="list-disc list-inside space-y-1.5 text-base">
                            {items.map((item, i) => (
                                <li key={i} dangerouslySetInnerHTML={{ __html: item.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') }} />
                            ))}
                        </ul>
                    )}
                    
                    {code && (
                        <pre className="bg-white p-4 rounded mt-3 text-sm font-mono whitespace-pre-wrap leading-relaxed">{code}</pre>
                    )}
                    
                    {table && (
                        <table className="w-full text-sm bg-white mt-2">
                            <thead className="bg-red-200">
                                <tr>
                                    {table[0].map((h, i) => (
                                        <th key={i} className="p-3 text-left font-bold">{h}</th>
                                    ))}
                                </tr>
                            </thead>
                            <tbody className="divide-y">
                                {table.slice(1).map((row, i) => (
                                    <tr key={i}>
                                        {row.map((cell, j) => (
                                            <td key={j} className={`p-3 ${j === 0 ? 'font-semibold' : ''}`}>{cell}</td>
                                        ))}
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    )}
                    
                    {questions && (
                        <div className="space-y-4 text-base mt-2">
                            {questions.map((q, i) => (
                                <div key={i} className="bg-white p-4 rounded shadow-sm">
                                    <strong className="text-red-700 block mb-2 text-lg">{q.q}</strong>
                                    <ul className="list-disc list-inside text-sm space-y-1.5">
                                        {q.a.map((ans, j) => (
                                            <li key={j} dangerouslySetInnerHTML={{ __html: ans.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') }} />
                                        ))}
                                    </ul>
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            );
        };

        const Section = ({ title, children, defaultOpen = false }) => {
            const [open, setOpen] = useState(defaultOpen);
            return (
                <div className="bg-white rounded-lg shadow-md mb-6 overflow-hidden">
                    <button onClick={() => setOpen(!open)} className="w-full px-6 py-4 flex justify-between items-center hover:bg-gray-50 transition">
                        <h2 className="text-lg font-bold">{title}</h2>
                        <span className="text-2xl font-bold">{open ? '‚àí' : '+'}</span>
                    </button>
                    {open && <div className="px-6 pb-6 pt-4">{children}</div>}
                </div>
            );
        };

        const App = () => {
            return (
                <div className="max-w-4xl mx-auto p-6">
                    {/* Header */}
                    <div className="bg-indigo-600 text-white rounded-lg shadow-xl p-8 mb-8 text-center">
                        <h1 className="text-4xl font-bold mb-2">Data Structures: Unit 4</h1>
                        <h2 className="text-2xl font-semibold mb-1">Trees</h2>
                        <p className="text-indigo-200 text-sm">Last Minute Revision Guide</p>
                    </div>

                    {/* Content Sections */}
                    {TREE_CONTENT.map(section => (
                        <Section key={section.id} title={section.title} defaultOpen={section.defaultOpen}>
                            {section.boxes.map((box, i) => (
                                <Box key={i} {...box} />
                            ))}
                        </Section>
                    ))}

                    {/* Footer */}
                    <footer className="mt-10 pt-6 border-t-2 border-slate-300 text-center">
                        <p className="text-slate-700 font-semibold text-lg">
                            Crafted with love by <span className="text-indigo-600 font-bold">ZenYukti</span>
                        </p>
                        <p className="text-slate-500 text-xs tracking-widest uppercase mt-1">
                            Learn. Build. Share
                        </p>
                    </footer>
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>